<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ブロック崩し - Arkanoid Style</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a1a;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
  overflow: hidden;
}
#gameContainer {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}
#hud {
  display: flex;
  justify-content: space-between;
  width: 800px;
  color: #fff;
  font-size: 18px;
  padding: 0 10px;
}
#hud span { text-shadow: 0 0 10px rgba(100,200,255,0.6); }
canvas {
  border: 2px solid #1a1a3a;
  border-radius: 8px;
  box-shadow: 0 0 40px rgba(60,60,180,0.3), inset 0 0 40px rgba(0,0,0,0.5);
  cursor: none;
}
#overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0.75);
  color: #fff;
  border-radius: 8px;
  z-index: 10;
  pointer-events: auto;
}
#overlay.hidden { display: none; pointer-events: none; }
#overlay h1 {
  font-size: 48px;
  margin-bottom: 10px;
  background: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff, #9b59b6);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: none;
}
#overlay h2 {
  font-size: 32px;
  margin-bottom: 10px;
  color: #ffd93d;
}
#overlay p {
  font-size: 18px;
  margin: 6px 0;
  color: #ccc;
}
#overlay .start-btn {
  margin-top: 24px;
  padding: 14px 48px;
  font-size: 22px;
  border: none;
  border-radius: 30px;
  background: linear-gradient(135deg, #4d96ff, #9b59b6);
  color: #fff;
  cursor: pointer;
  transition: transform 0.15s, box-shadow 0.15s;
  box-shadow: 0 4px 20px rgba(77,150,255,0.4);
}
#overlay .start-btn:hover {
  transform: scale(1.07);
  box-shadow: 0 6px 30px rgba(77,150,255,0.6);
}
.powerup-legend {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin-top: 16px;
  max-width: 500px;
}
.powerup-legend div {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 14px;
  color: #aaa;
}
.powerup-legend .icon {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 13px;
  font-weight: bold;
  color: #fff;
}
</style>
</head>
<body>
<div id="gameContainer">
  <div id="hud">
    <span>SCORE: <b id="scoreDisplay">0</b></span>
    <span>LEVEL: <b id="levelDisplay">1</b></span>
    <span id="livesDisplay"></span>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="overlay">
    <h1>ブロック崩し</h1>
    <p>パドルを操作してボールを跳ね返し、全てのブロックを破壊せよ！</p>
    <div class="powerup-legend">
      <div><span class="icon" style="background:#4d96ff;">W</span> パドル拡大</div>
      <div><span class="icon" style="background:#e74c3c;">S</span> スピードアップ</div>
      <div><span class="icon" style="background:#2ecc71;">+</span> 1UP</div>
      <div><span class="icon" style="background:#f39c12;">M</span> マルチボール</div>
      <div><span class="icon" style="background:#9b59b6;">P</span> 貫通ボール</div>
      <div><span class="icon" style="background:#e84393;">L</span> レーザー</div>
    </div>
    <button class="start-btn" id="startBtn">START</button>
    <p style="margin-top:14px;font-size:14px;color:#666;">マウスまたは左右キーで操作</p>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const scoreDisplay = document.getElementById('scoreDisplay');
const levelDisplay = document.getElementById('levelDisplay');
const livesDisplay = document.getElementById('livesDisplay');

// --- Audio (Web Audio API synth) ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
}
function playTone(freq, duration, type = 'square', vol = 0.1) {
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + duration);
}
const sfx = {
  hit: () => playTone(440, 0.05, 'square', 0.08),
  brick: () => playTone(660, 0.08, 'square', 0.1),
  wall: () => playTone(220, 0.04, 'triangle', 0.06),
  lose: () => playTone(150, 0.3, 'sawtooth', 0.1),
  powerup: () => { playTone(523, 0.08, 'sine', 0.1); setTimeout(() => playTone(784, 0.12, 'sine', 0.1), 80); },
  laser: () => playTone(880, 0.06, 'sawtooth', 0.06),
  levelUp: () => { [523,659,784,1047].forEach((f,i) => setTimeout(() => playTone(f, 0.15, 'sine', 0.1), i*100)); },
};

// --- Game State ---
let state = 'menu'; // menu, playing, paused, gameover, levelclear
let score = 0;
let lives = 3;
let level = 1;
let combo = 0;
let shakeTimer = 0;
let particles = [];
let powerups = [];
let lasers = [];
let balls = [];
let paddle, bricks;
let speedMultiplier = 1;
let piercingTimer = 0;
let laserTimer = 0;
let animId;
let mouseX = W / 2;

// --- Constants ---
const PADDLE_BASE_W = 120;
const PADDLE_H = 14;
const PADDLE_Y = H - 40;
const BALL_R = 7;
const BALL_BASE_SPEED = 5.5;
const BRICK_ROWS = 7;
const BRICK_COLS = 12;
const BRICK_W = 60;
const BRICK_H = 22;
const BRICK_PAD = 4;
const BRICK_OFFSET_X = (W - (BRICK_COLS * (BRICK_W + BRICK_PAD) - BRICK_PAD)) / 2;
const BRICK_OFFSET_Y = 60;
const POWERUP_DROP_RATE = 0.25;
const POWERUP_SPEED = 2.8;
const POWERUP_R = 12;

const BRICK_COLORS = [
  '#ff6b6b', '#ff9f43', '#ffd93d', '#6bcb77',
  '#4d96ff', '#9b59b6', '#e84393'
];
const BRICK_GLOW = [
  'rgba(255,107,107,0.5)', 'rgba(255,159,67,0.5)', 'rgba(255,217,61,0.5)',
  'rgba(107,203,119,0.5)', 'rgba(77,150,255,0.5)', 'rgba(155,89,182,0.5)',
  'rgba(232,67,147,0.5)'
];

const POWERUP_TYPES = [
  { id: 'wide',    label: 'W', color: '#4d96ff', desc: 'パドル拡大' },
  { id: 'speed',   label: 'S', color: '#e74c3c', desc: 'スピードUP' },
  { id: 'life',    label: '+', color: '#2ecc71', desc: '1UP' },
  { id: 'multi',   label: 'M', color: '#f39c12', desc: 'マルチボール' },
  { id: 'pierce',  label: 'P', color: '#9b59b6', desc: '貫通ボール' },
  { id: 'laser',   label: 'L', color: '#e84393', desc: 'レーザー' },
];

// --- Paddle ---
function createPaddle() {
  return { x: W / 2, w: PADDLE_BASE_W, wideTimer: 0 };
}

// --- Ball ---
function createBall(x, y, dx, dy) {
  return { x, y, dx, dy, speed: BALL_BASE_SPEED, trail: [] };
}
function launchBall() {
  const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.8;
  return createBall(paddle.x, PADDLE_Y - BALL_R - 2, Math.cos(angle), Math.sin(angle));
}

// --- Bricks ---
function createBricks() {
  const arr = [];
  for (let r = 0; r < BRICK_ROWS; r++) {
    for (let c = 0; c < BRICK_COLS; c++) {
      let hp = 1;
      // higher levels get tougher bricks
      if (level >= 2 && r < 2) hp = 2;
      if (level >= 3 && r === 0) hp = 3;
      if (level >= 4 && Math.random() < 0.15) hp = 3;
      arr.push({
        x: BRICK_OFFSET_X + c * (BRICK_W + BRICK_PAD),
        y: BRICK_OFFSET_Y + r * (BRICK_H + BRICK_PAD),
        w: BRICK_W,
        h: BRICK_H,
        color: BRICK_COLORS[r % BRICK_COLORS.length],
        glow: BRICK_GLOW[r % BRICK_GLOW.length],
        hp,
        maxHp: hp,
        alive: true
      });
    }
  }
  return arr;
}

// --- Particles ---
function spawnParticles(x, y, color, count = 8) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 1 + Math.random() * 3;
    particles.push({
      x, y,
      dx: Math.cos(angle) * speed,
      dy: Math.sin(angle) * speed,
      life: 1,
      decay: 0.02 + Math.random() * 0.03,
      color,
      r: 2 + Math.random() * 3
    });
  }
}

// --- Input ---
let keys = {};
document.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === 'p' && state === 'playing') { state = 'paused'; }
  else if (e.key === 'p' && state === 'paused') { state = 'playing'; }
});
document.addEventListener('keyup', e => keys[e.key] = false);
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) * (W / rect.width);
});

// --- Powerup Logic ---
function dropPowerup(x, y) {
  if (Math.random() > POWERUP_DROP_RATE) return;
  const type = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
  powerups.push({ x, y, type, vy: POWERUP_SPEED, glow: 0 });
}

function applyPowerup(p) {
  sfx.powerup();
  const id = p.type.id;
  if (id === 'wide') {
    paddle.w = PADDLE_BASE_W * 1.6;
    paddle.wideTimer = 600;
  } else if (id === 'speed') {
    speedMultiplier = Math.min(speedMultiplier + 0.3, 2.2);
  } else if (id === 'life') {
    lives = Math.min(lives + 1, 5);
  } else if (id === 'multi') {
    const newBalls = [];
    balls.forEach(b => {
      for (let i = 0; i < 2; i++) {
        const angle = Math.atan2(b.dy, b.dx) + (i === 0 ? 0.4 : -0.4);
        newBalls.push(createBall(b.x, b.y, Math.cos(angle), Math.sin(angle)));
      }
    });
    balls.push(...newBalls);
  } else if (id === 'pierce') {
    piercingTimer = 480;
  } else if (id === 'laser') {
    laserTimer = 480;
  }
  spawnParticles(p.x, p.y, p.type.color, 15);
}

// --- Collision Helpers ---
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function ballRectCollision(ball, rx, ry, rw, rh) {
  const cx = clamp(ball.x, rx, rx + rw);
  const cy = clamp(ball.y, ry, ry + rh);
  const dx = ball.x - cx;
  const dy = ball.y - cy;
  return dx * dx + dy * dy < BALL_R * BALL_R;
}

// --- Init Level ---
function initLevel() {
  bricks = createBricks();
  paddle = createPaddle();
  balls = [launchBall()];
  powerups = [];
  lasers = [];
  particles = [];
  speedMultiplier = 1;
  piercingTimer = 0;
  laserTimer = 0;
  combo = 0;
}

// --- Start Game ---
function startGame() {
  score = 0;
  lives = 3;
  level = 1;
  state = 'playing';
  overlay.classList.add('hidden');
  initLevel();
  updateHUD();
}

// --- HUD ---
function updateHUD() {
  scoreDisplay.textContent = score.toLocaleString();
  levelDisplay.textContent = level;
  let hearts = '';
  for (let i = 0; i < lives; i++) hearts += '\u2764 ';
  livesDisplay.innerHTML = hearts;
}

// --- Show Overlay ---
function showOverlay(title, sub, btnText) {
  overlay.classList.remove('hidden');
  overlay.innerHTML = `
    <h2>${title}</h2>
    <p>${sub}</p>
    <button class="start-btn" onclick="
      ${btnText === 'RETRY' ? 'startGame()' : btnText === 'NEXT LEVEL' ? 'nextLevel()' : 'startGame()'}
    ">${btnText}</button>
  `;
}

function nextLevel() {
  level++;
  state = 'playing';
  overlay.classList.add('hidden');
  initLevel();
  updateHUD();
}

// --- Update ---
function update() {
  if (state !== 'playing') return;

  // Paddle movement
  const padTarget = mouseX;
  if (keys['ArrowLeft'] || keys['a']) paddle.x -= 8;
  if (keys['ArrowRight'] || keys['d']) paddle.x += 8;
  paddle.x += (padTarget - paddle.x) * 0.25;
  paddle.x = clamp(paddle.x, paddle.w / 2, W - paddle.w / 2);

  // Wide timer
  if (paddle.wideTimer > 0) {
    paddle.wideTimer--;
    if (paddle.wideTimer <= 0) paddle.w = PADDLE_BASE_W;
  }

  // Piercing timer
  if (piercingTimer > 0) piercingTimer--;

  // Laser timer & shooting
  if (laserTimer > 0) {
    laserTimer--;
    if (laserTimer % 12 === 0) {
      lasers.push({ x: paddle.x - paddle.w / 2 + 8, y: PADDLE_Y - 6, dy: -8 });
      lasers.push({ x: paddle.x + paddle.w / 2 - 8, y: PADDLE_Y - 6, dy: -8 });
      sfx.laser();
    }
  }

  // Lasers
  for (let i = lasers.length - 1; i >= 0; i--) {
    const l = lasers[i];
    l.y += l.dy;
    if (l.y < 0) { lasers.splice(i, 1); continue; }
    // Laser-brick collision
    for (const b of bricks) {
      if (!b.alive) continue;
      if (l.x >= b.x && l.x <= b.x + b.w && l.y >= b.y && l.y <= b.y + b.h) {
        b.hp--;
        if (b.hp <= 0) {
          b.alive = false;
          score += 10 * level;
          dropPowerup(b.x + b.w / 2, b.y + b.h / 2);
          spawnParticles(b.x + b.w / 2, b.y + b.h / 2, b.color, 6);
        }
        lasers.splice(i, 1);
        sfx.brick();
        break;
      }
    }
  }

  // Balls
  const currentSpeed = BALL_BASE_SPEED * speedMultiplier;
  for (let bi = balls.length - 1; bi >= 0; bi--) {
    const ball = balls[bi];
    ball.speed = currentSpeed;

    // Trail
    ball.trail.push({ x: ball.x, y: ball.y });
    if (ball.trail.length > 10) ball.trail.shift();

    ball.x += ball.dx * ball.speed;
    ball.y += ball.dy * ball.speed;

    // Wall collisions
    if (ball.x - BALL_R < 0) { ball.x = BALL_R; ball.dx = Math.abs(ball.dx); sfx.wall(); }
    if (ball.x + BALL_R > W) { ball.x = W - BALL_R; ball.dx = -Math.abs(ball.dx); sfx.wall(); }
    if (ball.y - BALL_R < 0) { ball.y = BALL_R; ball.dy = Math.abs(ball.dy); sfx.wall(); }

    // Bottom - lose ball
    if (ball.y - BALL_R > H) {
      balls.splice(bi, 1);
      combo = 0;
      if (balls.length === 0) {
        lives--;
        updateHUD();
        sfx.lose();
        shakeTimer = 15;
        if (lives <= 0) {
          state = 'gameover';
          setTimeout(() => showOverlay('GAME OVER', `スコア: ${score.toLocaleString()}`, 'RETRY'), 600);
        } else {
          setTimeout(() => {
            balls = [launchBall()];
            speedMultiplier = 1;
          }, 500);
        }
      }
      continue;
    }

    // Paddle collision
    const px = paddle.x - paddle.w / 2;
    if (ballRectCollision(ball, px, PADDLE_Y, paddle.w, PADDLE_H) && ball.dy > 0) {
      const hitPos = (ball.x - paddle.x) / (paddle.w / 2); // -1 to 1
      const angle = hitPos * (Math.PI / 3) - Math.PI / 2;
      ball.dx = Math.cos(angle);
      ball.dy = Math.sin(angle);
      ball.y = PADDLE_Y - BALL_R;
      combo = 0;
      sfx.hit();
      spawnParticles(ball.x, PADDLE_Y, '#4d96ff', 4);
    }

    // Brick collision
    for (const brick of bricks) {
      if (!brick.alive) continue;
      if (ballRectCollision(ball, brick.x, brick.y, brick.w, brick.h)) {
        brick.hp--;
        if (brick.hp <= 0) {
          brick.alive = false;
          combo++;
          const comboBonus = Math.floor(combo / 3) * 5;
          score += (10 + comboBonus) * level;
          dropPowerup(brick.x + brick.w / 2, brick.y + brick.h / 2);
          spawnParticles(brick.x + brick.w / 2, brick.y + brick.h / 2, brick.color, 10);
          shakeTimer = 4;
        } else {
          spawnParticles(brick.x + brick.w / 2, brick.y + brick.h / 2, brick.color, 4);
        }
        sfx.brick();

        if (piercingTimer <= 0) {
          // Determine bounce direction
          const ballCX = ball.x;
          const ballCY = ball.y;
          const brickCX = brick.x + brick.w / 2;
          const brickCY = brick.y + brick.h / 2;
          const diffX = ballCX - brickCX;
          const diffY = ballCY - brickCY;
          if (Math.abs(diffX / brick.w) > Math.abs(diffY / brick.h)) {
            ball.dx = diffX > 0 ? Math.abs(ball.dx) : -Math.abs(ball.dx);
          } else {
            ball.dy = diffY > 0 ? Math.abs(ball.dy) : -Math.abs(ball.dy);
          }
        }
        break;
      }
    }
  }

  // Powerups
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    p.y += p.vy;
    p.glow = (p.glow + 0.05) % (Math.PI * 2);
    if (p.y > H) { powerups.splice(i, 1); continue; }
    // Paddle catch
    if (p.y + POWERUP_R > PADDLE_Y && p.y - POWERUP_R < PADDLE_Y + PADDLE_H &&
        p.x > paddle.x - paddle.w / 2 && p.x < paddle.x + paddle.w / 2) {
      applyPowerup(p);
      powerups.splice(i, 1);
    }
  }

  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.dx;
    p.y += p.dy;
    p.dy += 0.05;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Shake
  if (shakeTimer > 0) shakeTimer--;

  // Level clear check
  if (bricks.every(b => !b.alive)) {
    state = 'levelclear';
    sfx.levelUp();
    const bonus = lives * 100 * level;
    score += bonus;
    updateHUD();
    setTimeout(() => showOverlay('LEVEL CLEAR!', `ボーナス: +${bonus.toLocaleString()}`, 'NEXT LEVEL'), 800);
  }

  updateHUD();
}

// --- Draw ---
function draw() {
  ctx.save();

  // Screen shake
  if (shakeTimer > 0) {
    const sx = (Math.random() - 0.5) * shakeTimer * 0.8;
    const sy = (Math.random() - 0.5) * shakeTimer * 0.8;
    ctx.translate(sx, sy);
  }

  // Background
  ctx.fillStyle = '#0d0d24';
  ctx.fillRect(0, 0, W, H);

  // Grid lines
  ctx.strokeStyle = 'rgba(40,40,80,0.3)';
  ctx.lineWidth = 0.5;
  for (let x = 0; x < W; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
  for (let y = 0; y < H; y += 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

  // Bricks
  for (const b of bricks) {
    if (!b.alive) continue;
    // Glow
    ctx.shadowColor = b.glow;
    ctx.shadowBlur = 12;

    const alpha = b.hp / b.maxHp;
    ctx.fillStyle = b.color;
    ctx.globalAlpha = 0.4 + 0.6 * alpha;
    roundRect(ctx, b.x, b.y, b.w, b.h, 4);
    ctx.fill();

    // Shine
    const grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
    grad.addColorStop(0, 'rgba(255,255,255,0.25)');
    grad.addColorStop(0.5, 'rgba(255,255,255,0)');
    ctx.fillStyle = grad;
    roundRect(ctx, b.x, b.y, b.w, b.h / 2, 4);
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;

    // HP indicator for multi-hit bricks
    if (b.maxHp > 1) {
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(b.hp, b.x + b.w / 2, b.y + b.h / 2 + 4);
    }
  }

  // Lasers
  ctx.shadowColor = '#e84393';
  ctx.shadowBlur = 8;
  for (const l of lasers) {
    ctx.fillStyle = '#e84393';
    ctx.fillRect(l.x - 2, l.y, 4, 12);
  }
  ctx.shadowBlur = 0;

  // Powerups
  for (const p of powerups) {
    const glowSize = 1 + Math.sin(p.glow) * 0.3;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.scale(glowSize, glowSize);
    ctx.shadowColor = p.type.color;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(0, 0, POWERUP_R, 0, Math.PI * 2);
    ctx.fillStyle = p.type.color;
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.type.label, 0, 1);
    ctx.restore();
  }

  // Balls
  for (const ball of balls) {
    // Trail
    for (let i = 0; i < ball.trail.length; i++) {
      const t = ball.trail[i];
      const a = i / ball.trail.length * 0.4;
      ctx.beginPath();
      ctx.arc(t.x, t.y, BALL_R * (i / ball.trail.length), 0, Math.PI * 2);
      if (piercingTimer > 0) {
        ctx.fillStyle = `rgba(155,89,182,${a})`;
      } else {
        ctx.fillStyle = `rgba(255,255,255,${a})`;
      }
      ctx.fill();
    }
    // Ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
    if (piercingTimer > 0) {
      ctx.shadowColor = '#9b59b6';
      ctx.shadowBlur = 20;
      ctx.fillStyle = '#c39bd3';
    } else {
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 15;
      ctx.fillStyle = '#fff';
    }
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Paddle
  const px = paddle.x - paddle.w / 2;
  ctx.shadowColor = laserTimer > 0 ? '#e84393' : '#4d96ff';
  ctx.shadowBlur = 18;
  const padGrad = ctx.createLinearGradient(px, PADDLE_Y, px, PADDLE_Y + PADDLE_H);
  padGrad.addColorStop(0, laserTimer > 0 ? '#e84393' : '#5dade2');
  padGrad.addColorStop(1, laserTimer > 0 ? '#c0392b' : '#2e86c1');
  ctx.fillStyle = padGrad;
  roundRect(ctx, px, PADDLE_Y, paddle.w, PADDLE_H, 7);
  ctx.fill();
  ctx.shadowBlur = 0;

  // Paddle shine
  const shineGrad = ctx.createLinearGradient(px, PADDLE_Y, px, PADDLE_Y + PADDLE_H / 2);
  shineGrad.addColorStop(0, 'rgba(255,255,255,0.3)');
  shineGrad.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = shineGrad;
  roundRect(ctx, px + 2, PADDLE_Y + 1, paddle.w - 4, PADDLE_H / 2, 5);
  ctx.fill();

  // Particles
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Piercing indicator
  if (piercingTimer > 0) {
    ctx.fillStyle = '#9b59b6';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`貫通: ${Math.ceil(piercingTimer / 60)}s`, 10, H - 10);
  }
  // Laser indicator
  if (laserTimer > 0) {
    ctx.fillStyle = '#e84393';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`レーザー: ${Math.ceil(laserTimer / 60)}s`, 120, H - 10);
  }
  // Wide indicator
  if (paddle.wideTimer > 0) {
    ctx.fillStyle = '#4d96ff';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`拡大: ${Math.ceil(paddle.wideTimer / 60)}s`, 260, H - 10);
  }
  // Speed indicator
  if (speedMultiplier > 1.05) {
    ctx.fillStyle = '#e74c3c';
    ctx.font = '13px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`速度: x${speedMultiplier.toFixed(1)}`, 370, H - 10);
  }
  // Combo
  if (combo >= 3) {
    ctx.fillStyle = '#ffd93d';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`${combo} COMBO!`, W / 2, H - 10);
  }

  // Paused
  if (state === 'paused') {
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', W / 2, H / 2);
    ctx.font = '20px sans-serif';
    ctx.fillText('Pキーで再開', W / 2, H / 2 + 40);
  }

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// --- Game Loop ---
function gameLoop() {
  update();
  draw();
  animId = requestAnimationFrame(gameLoop);
}

// --- Event Handlers ---
startBtn.addEventListener('click', startGame);
document.addEventListener('keydown', e => {
  if (e.key === 'Enter' && (state === 'menu' || state === 'gameover')) startGame();
});

// Start render loop
gameLoop();
</script>
</body>
</html>
