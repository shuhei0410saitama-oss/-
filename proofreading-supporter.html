<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>マイルール校正サポーター</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #fafafa;
    --surface: #ffffff;
    --border: #e0e0e0;
    --text: #1a1a1a;
    --text-sub: #666;
    --accent: #2563eb;
    --accent-hover: #1d4ed8;
    --danger: #dc2626;
    --warn: #d97706;
    --warn-bg: #fffbeb;
    --warn-border: #fde68a;
    --error-bg: #fef2f2;
    --error-border: #fecaca;
    --info: #2563eb;
    --info-bg: #eff6ff;
    --info-border: #bfdbfe;
    --success: #16a34a;
    --success-bg: #f0fdf4;
    --fix-bg: #f0fdf4;
    --fix-border: #86efac;
    --radius: 6px;
    --font: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
  }

  body {
    font-family: var(--font);
    background: var(--bg);
    color: var(--text);
    line-height: 1.6;
    min-height: 100vh;
  }

  header {
    padding: 14px 24px;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 8px;
  }
  header h1 { font-size: 18px; font-weight: 600; letter-spacing: .02em; }
  header .subtitle { font-size: 12px; color: var(--text-sub); }

  .container { display: flex; height: calc(100vh - 57px); }
  .panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 20px;
    overflow-y: auto;
  }
  .panel-left {
    border-right: 1px solid var(--border);
    max-width: 500px;
    min-width: 320px;
    background: var(--surface);
  }
  .panel-right { flex: 1; background: var(--bg); }

  .section { margin-bottom: 16px; }
  .section-label {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: .06em;
    color: var(--text-sub);
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .char-count { font-weight: 400; font-size: 12px; color: var(--text-sub); }

  textarea {
    width: 100%;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 12px;
    font-family: var(--font);
    font-size: 14px;
    line-height: 1.7;
    resize: vertical;
    color: var(--text);
    background: var(--surface);
    transition: border-color .15s;
  }
  textarea:focus { outline: none; border-color: var(--accent); }
  textarea.rules-area { height: 140px; }
  textarea.body-area  { flex: 1; min-height: 240px; }

  button {
    font-family: var(--font);
    font-size: 13px;
    border: none;
    border-radius: var(--radius);
    padding: 8px 16px;
    cursor: pointer;
    transition: background .15s, opacity .15s;
    font-weight: 500;
  }
  button:active { opacity: .85; }
  button:disabled { opacity: .4; cursor: default; }
  .btn-primary { background: var(--accent); color: #fff; }
  .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
  .btn-fix { background: var(--success); color: #fff; }
  .btn-fix:hover:not(:disabled) { background: #15803d; }
  .btn-secondary { background: transparent; color: var(--accent); border: 1px solid var(--border); }
  .btn-secondary:hover { background: #f0f4ff; }
  .btn-small { font-size: 11px; padding: 4px 10px; }
  .btn-danger { background: transparent; color: var(--danger); border: 1px solid var(--border); }
  .btn-danger:hover { background: #fef2f2; }

  .presets { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px; }
  .preset-btn {
    background: #f1f5f9; color: var(--text);
    font-size: 12px; padding: 5px 12px; border-radius: 20px;
  }
  .preset-btn:hover { background: #e2e8f0; }
  .preset-btn.active { background: var(--accent); color: #fff; }

  .actions { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; }

  .results-container { flex: 1; overflow-y: auto; }
  .results-summary {
    padding: 14px 18px;
    border-radius: var(--radius);
    margin-bottom: 16px;
    font-size: 14px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .results-summary.has-issues { background: var(--warn-bg); border: 1px solid var(--warn-border); color: #92400e; }
  .results-summary.no-issues  { background: var(--success-bg); border: 1px solid #bbf7d0; color: #166534; }
  .results-summary .count { font-size: 24px; font-weight: 700; }
  .results-summary .summary-actions { margin-left: auto; }

  .issue-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 10px;
    overflow: hidden;
    transition: border-color .15s;
  }
  .issue-card:hover { border-color: #bbb; }
  .issue-card.fixed { opacity: .5; }
  .issue-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 16px;
    cursor: pointer;
    user-select: none;
  }
  .issue-header:hover { background: #fafafa; }
  .issue-badge {
    font-size: 10px;
    font-weight: 600;
    padding: 2px 8px;
    border-radius: 10px;
    text-transform: uppercase;
    letter-spacing: .04em;
    white-space: nowrap;
  }
  .badge-error  { background: var(--error-bg); color: var(--danger); border: 1px solid var(--error-border); }
  .badge-warn   { background: var(--warn-bg);  color: var(--warn);   border: 1px solid var(--warn-border); }
  .badge-info   { background: var(--info-bg);  color: var(--info);   border: 1px solid var(--info-border); }
  .badge-fixed  { background: var(--fix-bg);   color: var(--success); border: 1px solid var(--fix-border); }
  .issue-title { font-size: 13px; font-weight: 500; flex: 1; }
  .issue-toggle { font-size: 12px; color: var(--text-sub); transition: transform .2s; }
  .issue-card.open .issue-toggle { transform: rotate(180deg); }
  .issue-body {
    display: none;
    padding: 0 16px 14px 16px;
    font-size: 13px;
    line-height: 1.7;
  }
  .issue-card.open .issue-body { display: block; }
  .issue-excerpt {
    background: #f8f8f8;
    border-left: 3px solid var(--warn-border);
    padding: 8px 12px;
    margin: 6px 0;
    font-size: 13px;
    border-radius: 0 4px 4px 0;
    color: var(--text);
  }
  .issue-excerpt mark {
    background: #fde68a;
    padding: 1px 2px;
    border-radius: 2px;
  }
  .issue-fix-preview {
    margin-top: 8px;
    padding: 8px 12px;
    background: var(--fix-bg);
    border: 1px solid var(--fix-border);
    border-radius: 4px;
    font-size: 13px;
    color: #166534;
  }
  .issue-fix-preview .fix-arrow { color: var(--success); font-weight: 600; margin: 0 6px; }
  .issue-fix-preview .fix-from { text-decoration: line-through; color: var(--danger); }
  .issue-fix-preview .fix-to   { font-weight: 600; color: var(--success); }
  .issue-suggestion {
    margin-top: 8px;
    padding: 8px 12px;
    background: var(--info-bg);
    border-radius: 4px;
    font-size: 13px;
    color: #1e40af;
  }
  .issue-suggestion::before { content: "提案: "; font-weight: 600; }
  .issue-actions { margin-top: 10px; display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
  .issue-manual-input {
    display: flex;
    gap: 6px;
    align-items: center;
    margin-top: 8px;
    flex-wrap: wrap;
  }
  .issue-manual-input input {
    font-family: var(--font);
    font-size: 13px;
    padding: 5px 10px;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text);
    min-width: 120px;
    flex: 1;
  }
  .issue-manual-input input:focus { outline: none; border-color: var(--accent); }
  .issue-manual-input label {
    font-size: 12px;
    color: var(--text-sub);
    white-space: nowrap;
  }

  .empty-state {
    text-align: center;
    padding: 60px 20px;
    color: var(--text-sub);
    font-size: 14px;
  }
  .empty-state .icon { font-size: 40px; margin-bottom: 12px; opacity: .4; }

  .toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(80px);
    background: #1a1a1a;
    color: #fff;
    padding: 10px 24px;
    border-radius: var(--radius);
    font-size: 13px;
    opacity: 0;
    transition: transform .3s, opacity .3s;
    z-index: 100;
    pointer-events: none;
  }
  .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

  @media (max-width: 768px) {
    .container { flex-direction: column; height: auto; }
    .panel-left { max-width: none; border-right: none; border-bottom: 1px solid var(--border); }
    .panel-right { min-height: 60vh; }
  }
</style>
</head>
<body>

<header>
  <div>
    <h1>マイルール校正サポーター</h1>
    <div class="subtitle">ルールに基づいて文章を校正・修正します</div>
  </div>
</header>

<div class="container">
  <!-- ===== Left Panel ===== -->
  <div class="panel panel-left">
    <div class="section">
      <div class="section-label">プリセット</div>
      <div class="presets" id="presetContainer">
        <button class="preset-btn" data-preset="business-email">ビジネスメール用</button>
        <button class="preset-btn" data-preset="report">経理報告書用</button>
        <button class="preset-btn" data-preset="sns">SNS投稿用</button>
        <button class="preset-btn" data-preset="technical">技術文書用</button>
        <button class="preset-btn" data-preset="press">プレスリリース用</button>
      </div>
    </div>

    <div class="section">
      <div class="section-label">
        <span>守るべきルール</span>
        <span class="char-count" id="rulesCount">0 文字</span>
      </div>
      <textarea
        class="rules-area"
        id="rulesArea"
        placeholder="例：&#10;・専門用語を避け、平易な表現を使う&#10;・一文は60文字以内にする&#10;・「思います」などの曖昧表現を避ける&#10;・「サーバー」は「サーバ」に統一"
      ></textarea>
      <div class="actions">
        <button class="btn-secondary btn-small" id="saveRulesBtn">ルールを保存</button>
        <button class="btn-danger btn-small" id="clearRulesBtn">クリア</button>
      </div>
    </div>

    <div class="section" style="flex:1; display:flex; flex-direction:column;">
      <div class="section-label">
        <span>チェックしたい文章</span>
        <span class="char-count" id="bodyCount">0 文字</span>
      </div>
      <textarea
        class="body-area"
        id="bodyArea"
        placeholder="校正したい文章をここに入力してください..."
      ></textarea>
    </div>

    <div class="actions" style="margin-top:16px;">
      <button class="btn-primary" id="proofreadBtn" style="flex:1;">校正チェック実行</button>
    </div>
  </div>

  <!-- ===== Right Panel ===== -->
  <div class="panel panel-right">
    <div class="section-label">
      <span>校正結果</span>
      <span class="char-count" id="issueCount"></span>
    </div>
    <div class="results-container" id="resultsContainer">
      <div class="empty-state">
        <div class="icon">&#9998;</div>
        <div>左側にルールと本文を入力し、<br>「校正チェック実行」を押してください。</div>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(function () {
  // ══════════════════════════════════════════════════════════
  //  Elements
  // ══════════════════════════════════════════════════════════
  const rulesArea        = document.getElementById('rulesArea');
  const bodyArea         = document.getElementById('bodyArea');
  const proofreadBtn     = document.getElementById('proofreadBtn');
  const saveRulesBtn     = document.getElementById('saveRulesBtn');
  const clearRulesBtn    = document.getElementById('clearRulesBtn');
  const rulesCount       = document.getElementById('rulesCount');
  const bodyCount        = document.getElementById('bodyCount');
  const issueCountEl     = document.getElementById('issueCount');
  const toastEl          = document.getElementById('toast');
  const presetContainer  = document.getElementById('presetContainer');
  const resultsContainer = document.getElementById('resultsContainer');

  // Current issues (with fix data)
  let currentIssues = [];

  // ══════════════════════════════════════════════════════════
  //  Presets
  // ══════════════════════════════════════════════════════════
  const PRESETS = {
    'business-email': {
      text: [
        '・敬語を正しく使う（二重敬語を避ける）',
        '・結論を先に述べ、理由や背景を後に書く',
        '・一文は60文字以内を目安にする',
        '・曖昧な表現（「思います」「かもしれません」）を避ける',
        '・誤字脱字がないか確認する',
      ].join('\n'),
    },
    'report': {
      text: [
        '・数値には必ず単位と出典を明記する',
        '・事実と意見を明確に区別する',
        '・専門用語には初出時に説明を加える',
        '・日付や期間の表記を統一する',
      ].join('\n'),
    },
    'sns': {
      text: [
        '・一投稿あたり140文字以内に収める',
        '・誇張表現や誤解を招く表現を避ける',
        '・読み手の行動を促すCTAを含める',
      ].join('\n'),
    },
    'technical': {
      text: [
        '・技術用語の表記を統一する（例：サーバー / サーバ）',
        '・手順は番号付きリストで記述する',
        '・略語は初出時にフルスペルを併記する',
        '・主語と述語の対応を確認する',
      ].join('\n'),
    },
    'press': {
      text: [
        '・5W1H（誰が・何を・いつ・どこで・なぜ・どのように）を明記する',
        '・客観的な事実のみを記述し、主観を排除する',
        '・社名・製品名の表記を正式名称に統一する',
        '・誇張表現（「革命的」「世界初」等）は根拠がある場合のみ使用する',
      ].join('\n'),
    },
  };

  let activePreset = null;

  // ══════════════════════════════════════════════════════════
  //  Helpers
  // ══════════════════════════════════════════════════════════
  function splitSentences(text) {
    const results = [];
    const raw = text.split(/(?<=。)|(?<=\n)/);
    let pos = 0;
    for (const seg of raw) {
      const trimmed = seg.replace(/^\n+/, '');
      if (trimmed.length === 0) { pos += seg.length; continue; }
      results.push({ text: trimmed, start: pos + (seg.length - trimmed.length), end: pos + seg.length });
      pos += seg.length;
    }
    return results;
  }

  function excerpt(text, matchStart, matchEnd, contextLen) {
    contextLen = contextLen || 20;
    const start = Math.max(0, matchStart - contextLen);
    const end   = Math.min(text.length, matchEnd + contextLen);
    const before = (start > 0 ? '…' : '') + escHtml(text.slice(start, matchStart));
    const match  = '<mark>' + escHtml(text.slice(matchStart, matchEnd)) + '</mark>';
    const after  = escHtml(text.slice(matchEnd, end)) + (end < text.length ? '…' : '');
    return before + match + after;
  }

  function escHtml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function escRegex(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  // ══════════════════════════════════════════════════════════
  //  Check functions – each issue now has optional `fix` field
  //  fix: { from: 'matched text', to: 'replacement' }
  // ══════════════════════════════════════════════════════════

  function checkLongSentences(text, maxLen) {
    const issues = [];
    const sentences = splitSentences(text);
    for (const s of sentences) {
      const clean = s.text.replace(/\s/g, '');
      if (clean.length > maxLen) {
        issues.push({
          severity: 'warn',
          rule: '一文が長すぎる',
          message: `この文は${clean.length}文字あります（上限: ${maxLen}文字）。`,
          excerpt: excerpt(text, s.start, s.end, 10),
          suggestion: '読点（、）の位置で文を分割してください。',
          fix: null,
        });
      }
    }
    return issues;
  }

  function checkAmbiguousExpressions(text) {
    const patterns = [
      { re: /思います/g,      word: '思います',      to: null, fix_desc: '「です」「ます」など断定表現に変更' },
      { re: /かもしれません/g, word: 'かもしれません', to: null, fix_desc: '確信がある場合は断定表現に変更' },
      { re: /だと思う/g,       word: 'だと思う',       to: 'である', fix_desc: null },
      { re: /かもしれない/g,   word: 'かもしれない',   to: null, fix_desc: '事実であれば断定表現に変更' },
      { re: /ような気がする/g, word: 'ような気がする', to: null, fix_desc: '根拠がある場合は明確に記述' },
      { re: /(?:たぶん|多分)/g, word: 'たぶん/多分',   to: '', fix_desc: null },
      { re: /(?:おそらく)/g,   word: 'おそらく',       to: '', fix_desc: null },
      { re: /(?:一応)/g,       word: '一応',           to: '', fix_desc: null },
      { re: /(?:なんとなく)/g, word: 'なんとなく',     to: '', fix_desc: null },
      { re: /ちょっと/g,       word: 'ちょっと',       to: '少し', fix_desc: null },
      { re: /(?:いろいろ|色々)(?!な[具特])/g, word: 'いろいろ/色々', to: null, fix_desc: '具体的な内容を列挙する' },
    ];
    const issues = [];
    for (const p of patterns) {
      let m;
      while ((m = p.re.exec(text)) !== null) {
        const matched = m[0];
        const fixObj = p.to !== null ? { from: matched, to: p.to } : null;
        issues.push({
          severity: 'warn',
          rule: '曖昧な表現',
          message: `「${p.word}」は曖昧な表現です。`,
          excerpt: excerpt(text, m.index, m.index + matched.length),
          suggestion: fixObj ? null : (p.fix_desc || '断定表現に変更してください'),
          fix: fixObj,
        });
      }
    }
    return issues;
  }

  function checkDoubleHonorifics(text) {
    const patterns = [
      { re: /おっしゃられ/g, from: 'おっしゃられ', to: 'おっしゃ' },
      { re: /ご覧になられ/g, from: 'ご覧になられ', to: 'ご覧にな' },
      { re: /お召し上がりになられ/g, from: 'お召し上がりになられ', to: '召し上が' },
      { re: /ご利用になられ/g, from: 'ご利用になられ', to: 'ご利用にな' },
      { re: /お帰りになられ/g, from: 'お帰りになられ', to: 'お帰りにな' },
      { re: /させていただきますでしょうか/g, from: 'させていただきますでしょうか', to: 'させていただけますか' },
    ];
    const issues = [];
    for (const p of patterns) {
      let m;
      while ((m = p.re.exec(text)) !== null) {
        issues.push({
          severity: 'error',
          rule: '二重敬語',
          message: `「${p.from}」は二重敬語です。`,
          excerpt: excerpt(text, m.index, m.index + m[0].length),
          suggestion: null,
          fix: { from: m[0], to: p.to },
        });
      }
    }
    return issues;
  }

  function checkRedundantExpressions(text) {
    const patterns = [
      { re: /まず最初に/g,     from: 'まず最初に',  to: 'まず' },
      { re: /後で後悔/g,       from: '後で後悔',    to: '後悔' },
      { re: /一番最初/g,       from: '一番最初',    to: '最初' },
      { re: /一番最後/g,       from: '一番最後',    to: '最後' },
      { re: /必ず必要/g,       from: '必ず必要',    to: '必要' },
      { re: /頭痛が痛い/g,     from: '頭痛が痛い',  to: '頭が痛い' },
      { re: /違和感を感じ/g,   from: '違和感を感じ', to: '違和感を覚え' },
      { re: /犯罪を犯す/g,     from: '犯罪を犯す',  to: '罪を犯す' },
      { re: /犯罪を犯し/g,     from: '犯罪を犯し',  to: '罪を犯し' },
      { re: /被害を被る/g,     from: '被害を被る',  to: '被害を受ける' },
      { re: /被害を被っ/g,     from: '被害を被っ',  to: '被害を受け' },
      { re: /元旦の朝/g,       from: '元旦の朝',    to: '元旦' },
      { re: /返事を返す/g,     from: '返事を返す',  to: '返事をする' },
      { re: /馬から落馬/g,     from: '馬から落馬',  to: '落馬' },
      { re: /日本に来日/g,     from: '日本に来日',  to: '来日' },
      { re: /あとで後悔/g,     from: 'あとで後悔',  to: '後悔' },
    ];
    const issues = [];
    for (const p of patterns) {
      let m;
      while ((m = p.re.exec(text)) !== null) {
        issues.push({
          severity: 'error',
          rule: '重複表現',
          message: `「${p.from}」は意味が重複しています。`,
          excerpt: excerpt(text, m.index, m.index + m[0].length),
          suggestion: null,
          fix: { from: m[0], to: p.to },
        });
      }
    }
    return issues;
  }

  function checkConsecutiveSameParticle(text) {
    const issues = [];
    const sentences = splitSentences(text);
    const particles = ['は','が','を','に','の'];
    for (const s of sentences) {
      if (s.text.length < 15) continue;
      for (const p of particles) {
        const count = (s.text.match(new RegExp(p, 'g')) || []).length;
        if (count >= 4) {
          issues.push({
            severity: 'info',
            rule: '助詞の連続使用',
            message: `一文中に「${p}」が${count}回使われています。`,
            excerpt: excerpt(text, s.start, s.end, 5),
            suggestion: '文を分割するか、別の表現に言い換えてみてください。',
            fix: null,
          });
        }
      }
    }
    return issues;
  }

  function checkDesumasu(text) {
    const sentences = splitSentences(text);
    let desumasuCount = 0, deCount = 0;
    const desumasuSentences = [], deSentences = [];
    for (const s of sentences) {
      const t = s.text.trim();
      if (t.length < 5) continue;
      if (/(?:です|ます|ました|ません|でしょう)[。？！\s]*$/.test(t)) {
        desumasuCount++; desumasuSentences.push(s);
      } else if (/(?:だ|である|った|ない|であろう)[。？！\s]*$/.test(t)) {
        deCount++; deSentences.push(s);
      }
    }
    const issues = [];
    if (desumasuCount > 0 && deCount > 0) {
      const isDesumasuMajority = desumasuCount >= deCount;
      const minority = isDesumasuMajority ? deSentences : desumasuSentences;
      const majorStyle = isDesumasuMajority ? 'です・ます調' : 'だ・である調';
      const minorStyle = isDesumasuMajority ? 'だ・である調' : 'です・ます調';
      for (const s of minority.slice(0, 5)) {
        issues.push({
          severity: 'warn',
          rule: '文体の不統一',
          message: `大部分は${majorStyle}ですが、この文は${minorStyle}です。`,
          excerpt: excerpt(text, s.start, s.end, 5),
          suggestion: `文体を${majorStyle}に統一してください。`,
          fix: null,
        });
      }
    }
    return issues;
  }

  function checkSpacingIssues(text) {
    const issues = [];
    let m;
    const fwNumbers = /[０-９]+/g;
    while ((m = fwNumbers.exec(text)) !== null) {
      const hw = m[0].replace(/[０-９]/g, c => String.fromCharCode(c.charCodeAt(0) - 0xFEE0));
      issues.push({
        severity: 'info',
        rule: '全角数字',
        message: '全角数字が使われています。',
        excerpt: excerpt(text, m.index, m.index + m[0].length),
        suggestion: null,
        fix: { from: m[0], to: hw },
      });
    }
    const hwKatakana = /[\uFF65-\uFF9F]+/g;
    while ((m = hwKatakana.exec(text)) !== null) {
      // Simple half->full katakana conversion
      const full = halfToFullKatakana(m[0]);
      issues.push({
        severity: 'warn',
        rule: '半角カタカナ',
        message: '半角カタカナが使われています。',
        excerpt: excerpt(text, m.index, m.index + m[0].length),
        suggestion: null,
        fix: { from: m[0], to: full },
      });
    }
    return issues;
  }

  function halfToFullKatakana(str) {
    const map = {
      'ｦ':'ヲ','ｧ':'ァ','ｨ':'ィ','ｩ':'ゥ','ｪ':'ェ','ｫ':'ォ','ｬ':'ャ','ｭ':'ュ','ｮ':'ョ','ｯ':'ッ',
      'ｰ':'ー','ｱ':'ア','ｲ':'イ','ｳ':'ウ','ｴ':'エ','ｵ':'オ','ｶ':'カ','ｷ':'キ','ｸ':'ク','ｹ':'ケ','ｺ':'コ',
      'ｻ':'サ','ｼ':'シ','ｽ':'ス','ｾ':'セ','ｿ':'ソ','ﾀ':'タ','ﾁ':'チ','ﾂ':'ツ','ﾃ':'テ','ﾄ':'ト',
      'ﾅ':'ナ','ﾆ':'ニ','ﾇ':'ヌ','ﾈ':'ネ','ﾉ':'ノ','ﾊ':'ハ','ﾋ':'ヒ','ﾌ':'フ','ﾍ':'ヘ','ﾎ':'ホ',
      'ﾏ':'マ','ﾐ':'ミ','ﾑ':'ム','ﾒ':'メ','ﾓ':'モ','ﾔ':'ヤ','ﾕ':'ユ','ﾖ':'ヨ',
      'ﾗ':'ラ','ﾘ':'リ','ﾙ':'ル','ﾚ':'レ','ﾛ':'ロ','ﾜ':'ワ','ﾝ':'ン','ﾞ':'゛','ﾟ':'゜','･':'・',
    };
    // Handle dakuten/handakuten combinations
    const dakuten = {'カ':'ガ','キ':'ギ','ク':'グ','ケ':'ゲ','コ':'ゴ','サ':'ザ','シ':'ジ','ス':'ズ','セ':'ゼ','ソ':'ゾ',
      'タ':'ダ','チ':'ヂ','ツ':'ヅ','テ':'デ','ト':'ド','ハ':'バ','ヒ':'ビ','フ':'ブ','ヘ':'ベ','ホ':'ボ','ウ':'ヴ'};
    const handakuten = {'ハ':'パ','ヒ':'ピ','フ':'プ','ヘ':'ペ','ホ':'ポ'};
    let result = '';
    for (let i = 0; i < str.length; i++) {
      const c = map[str[i]] || str[i];
      if (str[i+1] === 'ﾞ' && dakuten[c]) { result += dakuten[c]; i++; }
      else if (str[i+1] === 'ﾟ' && handakuten[c]) { result += handakuten[c]; i++; }
      else { result += c; }
    }
    return result;
  }

  function checkExaggeration(text) {
    const patterns = [
      { re: /革命的/g, word: '革命的' },
      { re: /世界初/g, word: '世界初' },
      { re: /業界初/g, word: '業界初' },
      { re: /史上最[高大強良好美]/g, word: '史上最〜' },
      { re: /唯一無二/g, word: '唯一無二' },
      { re: /画期的/g, word: '画期的' },
      { re: /完璧/g, word: '完璧' },
      { re: /絶対[にな]/g, word: '絶対に' },
    ];
    const issues = [];
    for (const p of patterns) {
      let m;
      while ((m = p.re.exec(text)) !== null) {
        issues.push({
          severity: 'info',
          rule: '誇張表現',
          message: `「${p.word}」は誇張表現の可能性があります。`,
          excerpt: excerpt(text, m.index, m.index + m[0].length),
          suggestion: '客観的な根拠を添えるか、より控えめな表現に修正してください。',
          fix: null,
        });
      }
    }
    return issues;
  }

  function checkUserKeywordRules(text, rulesText) {
    const issues = [];
    const lines = rulesText.split('\n');

    for (const rawLine of lines) {
      const line = rawLine.replace(/^[\s・\-\*\d.、]+/, '').trim();
      if (!line) continue;

      // ── 1. Replace A with B ──
      let match = line.match(/[「『](.+?)[」』].*?(?:は|を)[「『](.+?)[」』].*?(?:統一|置き換|変更|修正|書き換)/);
      if (!match) {
        match = line.match(/^(.+?)(?:を|は)(.+?)に(?:統一|置き換|変更|修正|書き換)/);
      }
      if (match) {
        const from = match[1].replace(/[「」『』。、]/g, '').trim();
        const to   = match[2].replace(/[「」『』。、]/g, '').trim();
        if (from && to && from !== to) {
          try {
            const re = new RegExp(escRegex(from), 'g');
            let m;
            while ((m = re.exec(text)) !== null) {
              issues.push({
                severity: 'error',
                rule: 'カスタムルール違反',
                message: `「${from}」は「${to}」に統一するルールです。`,
                excerpt: excerpt(text, m.index, m.index + m[0].length),
                suggestion: null,
                fix: { from: m[0], to: to },
              });
            }
          } catch(e) {}
          continue;
        }
      }

      // ── 2. Avoid keyword ──
      const avoidVerbs = /(?:を?避け|を?使わな|を?使用しな|を?用いな|は?禁止|は?NG|は?ダメ|は?不可|しない(?:こと)?)/;
      match = line.match(new RegExp('[「『](.+?)[」』].*?' + avoidVerbs.source));
      if (!match) {
        match = line.match(new RegExp('^(.+?)(?:[。、]*)' + avoidVerbs.source));
      }
      if (match) {
        const word = match[1].replace(/[「」『』。、]/g, '').trim();
        if (word && word.length >= 1) {
          try {
            const re = new RegExp(escRegex(word), 'g');
            let m;
            while ((m = re.exec(text)) !== null) {
              issues.push({
                severity: 'error',
                rule: 'カスタムルール違反',
                message: `「${word}」の使用はルールで禁止されています。`,
                excerpt: excerpt(text, m.index, m.index + m[0].length),
                suggestion: null,
                fix: null,
                matchedText: m[0],
              });
            }
          } catch(e) {}
          continue;
        }
      }

      // ── 3. Fallback ──
      match = line.match(/^(.+?)[。、]*を(?:使わな|避け|使用しな)/);
      if (match) {
        const word = match[1].replace(/[「」『』。、\s]/g, '').trim();
        if (word && word.length >= 1) {
          try {
            const re = new RegExp(escRegex(word), 'g');
            let m;
            while ((m = re.exec(text)) !== null) {
              issues.push({
                severity: 'error',
                rule: 'カスタムルール違反',
                message: `「${word}」の使用はルールで禁止されています。`,
                excerpt: excerpt(text, m.index, m.index + m[0].length),
                suggestion: null,
                fix: null,
                matchedText: m[0],
              });
            }
          } catch(e) {}
        }
      }
    }
    return issues;
  }

  // ══════════════════════════════════════════════════════════
  //  Run checks
  // ══════════════════════════════════════════════════════════
  function parseActiveChecks(rulesText) {
    const checks = {
      longSentence: false, longSentenceMax: 60,
      ambiguous: false, doubleHonorific: false,
      redundant: true, consecutiveParticle: false,
      desumasu: false, spacing: true,
      exaggeration: false, userKeywords: true,
    };
    if (/一文.{0,5}\d+文字|文.*短く|文.*分割|文.*長/u.test(rulesText)) {
      checks.longSentence = true;
      const n = rulesText.match(/(\d+)\s*文字/);
      if (n) checks.longSentenceMax = parseInt(n[1], 10);
    }
    if (/曖昧|あいまい|断定|思います/.test(rulesText)) checks.ambiguous = true;
    if (/敬語|二重敬語|丁寧/.test(rulesText))           checks.doubleHonorific = true;
    if (/助詞/.test(rulesText))                          checks.consecutiveParticle = true;
    if (/文体|です.*ます|だ.*である|統一.*調/.test(rulesText)) checks.desumasu = true;
    if (/誇張|控えめ|客観/.test(rulesText))              checks.exaggeration = true;
    return checks;
  }

  function runProofreading(text, rulesText) {
    const c = parseActiveChecks(rulesText);
    let issues = [];
    issues = issues.concat(checkRedundantExpressions(text));
    issues = issues.concat(checkSpacingIssues(text));
    if (c.longSentence)       issues = issues.concat(checkLongSentences(text, c.longSentenceMax));
    if (c.ambiguous)          issues = issues.concat(checkAmbiguousExpressions(text));
    if (c.doubleHonorific)    issues = issues.concat(checkDoubleHonorifics(text));
    if (c.consecutiveParticle)issues = issues.concat(checkConsecutiveSameParticle(text));
    if (c.desumasu)           issues = issues.concat(checkDesumasu(text));
    if (c.exaggeration)       issues = issues.concat(checkExaggeration(text));
    if (c.userKeywords)       issues = issues.concat(checkUserKeywordRules(text, rulesText));

    const order = { error: 0, warn: 1, info: 2 };
    issues.sort((a, b) => (order[a.severity] || 9) - (order[b.severity] || 9));
    return issues;
  }

  // ══════════════════════════════════════════════════════════
  //  Apply fixes
  // ══════════════════════════════════════════════════════════
  function applyFix(issue) {
    if (!issue.fix) return false;
    const text = bodyArea.value;
    const idx = text.indexOf(issue.fix.from);
    if (idx === -1) return false;
    bodyArea.value = text.substring(0, idx) + issue.fix.to + text.substring(idx + issue.fix.from.length);
    updateCounts();
    return true;
  }

  function applyAllFixes() {
    let text = bodyArea.value;
    const fixable = currentIssues.filter(i => i.fix && !i.applied);

    // Build unique replacements (deduplicate same from->to)
    const seen = new Set();
    const replacements = [];
    for (const issue of fixable) {
      const key = issue.fix.from + '→' + issue.fix.to;
      if (!seen.has(key)) {
        seen.add(key);
        replacements.push(issue.fix);
      }
    }

    // Sort by from length descending to avoid partial matches
    replacements.sort((a, b) => b.from.length - a.from.length);

    let count = 0;
    for (const r of replacements) {
      const re = new RegExp(escRegex(r.from), 'g');
      const before = text;
      text = text.replace(re, r.to);
      if (text !== before) count++;
    }

    bodyArea.value = text;
    updateCounts();
    return count;
  }

  // ══════════════════════════════════════════════════════════
  //  Render results
  // ══════════════════════════════════════════════════════════
  function renderResults(issues) {
    resultsContainer.innerHTML = '';
    currentIssues = issues;

    if (issues.length === 0) {
      resultsContainer.innerHTML =
        '<div class="results-summary no-issues">' +
        '<span class="count">0</span> 問題は見つかりませんでした。</div>' +
        '<div class="empty-state"><div class="icon">&#10003;</div><div>すべてのチェックに合格しました。</div></div>';
      issueCountEl.textContent = '';
      return;
    }

    const fixableCount = issues.filter(i => i.fix).length;
    const errors = issues.filter(i => i.severity === 'error').length;
    const warns  = issues.filter(i => i.severity === 'warn').length;
    const infos  = issues.filter(i => i.severity === 'info').length;

    const parts = [];
    if (errors) parts.push(errors + ' 件のエラー');
    if (warns)  parts.push(warns  + ' 件の警告');
    if (infos)  parts.push(infos  + ' 件の情報');

    const summary = document.createElement('div');
    summary.className = 'results-summary has-issues';
    summary.innerHTML =
      '<span class="count">' + issues.length + '</span>' +
      '<span>' + parts.join('、') + ' が見つかりました</span>' +
      (fixableCount > 0
        ? '<span class="summary-actions"><button class="btn-fix btn-small" id="fixAllBtn">自動修正できる ' + fixableCount + ' 件をすべて修正</button></span>'
        : '');
    resultsContainer.appendChild(summary);

    issueCountEl.textContent = issues.length + ' 件';

    // Fix all button handler
    const fixAllBtn = document.getElementById('fixAllBtn');
    if (fixAllBtn) {
      fixAllBtn.addEventListener('click', function () {
        const count = applyAllFixes();
        showToast(count + ' 種類の修正を適用しました');
        // Re-run check
        const newIssues = runProofreading(bodyArea.value.trim(), rulesArea.value.trim());
        renderResults(newIssues);
      });
    }

    for (let i = 0; i < issues.length; i++) {
      const issue = issues[i];
      const card = document.createElement('div');
      card.className = 'issue-card open'; // default open

      const badgeClass = issue.severity === 'error' ? 'badge-error' :
                         issue.severity === 'warn'  ? 'badge-warn' : 'badge-info';
      const badgeLabel = issue.severity === 'error' ? 'エラー' :
                         issue.severity === 'warn'  ? '警告' : '情報';

      let bodyHtml = '';
      if (issue.excerpt) {
        bodyHtml += '<div class="issue-excerpt">' + issue.excerpt + '</div>';
      }

      if (issue.fix) {
        // Auto-fixable: show preview and one-click fix button
        bodyHtml +=
          '<div class="issue-fix-preview">' +
            '<span class="fix-from">' + escHtml(issue.fix.from) + '</span>' +
            '<span class="fix-arrow">→</span>' +
            '<span class="fix-to">' + (issue.fix.to === '' ? '（削除）' : escHtml(issue.fix.to)) + '</span>' +
          '</div>' +
          '<div class="issue-actions">' +
            '<button class="btn-fix btn-small issue-fix-btn" data-idx="' + i + '">この箇所を修正</button>' +
          '</div>';
      } else {
        // No auto-fix: show manual replacement input
        const original = issue.matchedText || '';
        if (original) {
          bodyHtml +=
            '<div class="issue-manual-input">' +
              '<label>「' + escHtml(original) + '」→</label>' +
              '<input type="text" class="manual-replace-input" data-idx="' + i + '" placeholder="置き換え先を入力（空欄で削除）">' +
              '<button class="btn-fix btn-small manual-replace-btn" data-idx="' + i + '">修正</button>' +
            '</div>';
        }
        if (issue.suggestion) {
          bodyHtml += '<div class="issue-suggestion">' + escHtml(issue.suggestion) + '</div>';
        }
      }

      card.innerHTML =
        '<div class="issue-header">' +
          '<span class="issue-badge ' + badgeClass + '">' + badgeLabel + '</span>' +
          '<span class="issue-title">' + escHtml(issue.rule) + ': ' + escHtml(issue.message) + '</span>' +
          '<span class="issue-toggle">&#9660;</span>' +
        '</div>' +
        '<div class="issue-body">' + bodyHtml + '</div>';

      card.querySelector('.issue-header').addEventListener('click', function () {
        card.classList.toggle('open');
      });

      // Auto-fix button
      const fixBtn = card.querySelector('.issue-fix-btn');
      if (fixBtn) {
        fixBtn.addEventListener('click', function () {
          const idx = parseInt(this.dataset.idx, 10);
          const target = currentIssues[idx];
          if (applyFix(target)) {
            showToast('修正しました');
            const newIssues = runProofreading(bodyArea.value.trim(), rulesArea.value.trim());
            renderResults(newIssues);
          } else {
            showToast('該当箇所が見つかりません');
          }
        });
      }

      // Manual replace button
      const manualBtn = card.querySelector('.manual-replace-btn');
      if (manualBtn) {
        manualBtn.addEventListener('click', function () {
          const idx = parseInt(this.dataset.idx, 10);
          const target = currentIssues[idx];
          const input = card.querySelector('.manual-replace-input');
          const replacement = input ? input.value : '';
          const original = target.matchedText;
          if (!original) return;

          const text = bodyArea.value;
          const pos = text.indexOf(original);
          if (pos === -1) { showToast('該当箇所が見つかりません'); return; }
          bodyArea.value = text.substring(0, pos) + replacement + text.substring(pos + original.length);
          updateCounts();
          showToast('修正しました');
          const newIssues = runProofreading(bodyArea.value.trim(), rulesArea.value.trim());
          renderResults(newIssues);
        });

        // Enter key support
        const input = card.querySelector('.manual-replace-input');
        if (input) {
          input.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') { manualBtn.click(); }
          });
        }
      }

      resultsContainer.appendChild(card);
    }
  }

  // ══════════════════════════════════════════════════════════
  //  Toast
  // ══════════════════════════════════════════════════════════
  let toastTimer = null;
  function showToast(msg) {
    clearTimeout(toastTimer);
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    toastTimer = setTimeout(() => toastEl.classList.remove('show'), 2000);
  }

  // ══════════════════════════════════════════════════════════
  //  Character count
  // ══════════════════════════════════════════════════════════
  function updateCounts() {
    rulesCount.textContent = rulesArea.value.length + ' 文字';
    bodyCount.textContent  = bodyArea.value.length  + ' 文字';
  }
  rulesArea.addEventListener('input', updateCounts);
  bodyArea.addEventListener('input', updateCounts);

  // ══════════════════════════════════════════════════════════
  //  Preset handling
  // ══════════════════════════════════════════════════════════
  rulesArea.addEventListener('input', function () {
    if (activePreset) {
      activePreset = null;
      document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
    }
  });

  presetContainer.addEventListener('click', function (e) {
    const btn = e.target.closest('.preset-btn');
    if (!btn) return;
    const key = btn.dataset.preset;
    if (!PRESETS[key]) return;
    if (activePreset === key) {
      activePreset = null;
      btn.classList.remove('active');
      rulesArea.value = '';
    } else {
      activePreset = key;
      document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      rulesArea.value = PRESETS[key].text;
    }
    updateCounts();
  });

  // ══════════════════════════════════════════════════════════
  //  Main action
  // ══════════════════════════════════════════════════════════
  proofreadBtn.addEventListener('click', function () {
    const rules = rulesArea.value.trim();
    const body  = bodyArea.value.trim();
    if (!rules && !body) { showToast('ルールと本文を入力してください'); return; }
    if (!rules) { showToast('ルールを入力してください'); return; }
    if (!body)  { showToast('本文を入力してください');     return; }

    const issues = runProofreading(body, rules);
    renderResults(issues);
    showToast(issues.length > 0 ? issues.length + ' 件の指摘が見つかりました' : '問題は見つかりませんでした');
  });

  // ══════════════════════════════════════════════════════════
  //  Save / Clear rules
  // ══════════════════════════════════════════════════════════
  saveRulesBtn.addEventListener('click', function () {
    localStorage.setItem('proofreader_rules', rulesArea.value);
    showToast('ルールを保存しました');
  });

  clearRulesBtn.addEventListener('click', function () {
    rulesArea.value = '';
    activePreset = null;
    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
    updateCounts();
  });

  // ══════════════════════════════════════════════════════════
  //  Init
  // ══════════════════════════════════════════════════════════
  (function init() {
    const saved = localStorage.getItem('proofreader_rules');
    if (saved) rulesArea.value = saved;
    updateCounts();
  })();
})();
</script>
</body>
</html>
